#!/usr/bin/php
<?php
/** 
 * @todo describe me
 */
 
require_once(__DIR__. '/parse-arguments.inc.php');

/* 
 * Named constants
 */

// Argument names identified with a prefix
define('ARG_PREFIX', '--');

// Argument names
define('ARG_HELP',    'help');
define('ARG_DATA',    'data');
define('ARG_FILE',    'file');

// Each data directory has a structure file that defines
// the community/collection to which it corresponds
define('STRUCTURE_FILE', 'structure.xml');

// Each data directory that corresponds to an imported community
// or collection will have its handle written to a text file
define('HANDLE_FILE', 'handle.txt');

/* 
 *  Parse & validate arguments
 */
$args = parse_arguments($argv);

if (empty($args) or array_key_exists(ARG_HELP, $args)) {
  echo usage();
  exit();
}

foreach (array(ARG_DATA, ARG_FILE) as $required_arg) {
  if (! array_key_exists($required_arg, $args) or ! isset($args[$required_arg])) {
    echo PHP_EOL, 'Required argument missing: ', ARG_PREFIX.$required_arg, PHP_EOL;
    echo usage();
    exit(E_USER_ERROR);
  }
}

/*
 * Load IMPORTED community/collection structure &
 * prepare resulting DOM for XPath queries
 */
$imported_dom = new DOMDocument();
$imported_dom->load($args[ARG_FILE]);
$imported_xpath = new DOMXpath($imported_dom);



/*
 * Output handle identifiers for each imported community/collection
 */
map_handles($imported_xpath, $imported_dom->documentElement, $args[ARG_DATA]);

// starting in data dir
// foreach dir with a structure.xml file
// read find node=community/name or node=collection/name from structure.xml
// parent defined? then parent = root or <imported_structure>
// look up node=(community or collection)[name = $name] and node parent = parent
// get handle 
// write handle to handle.txt
// parent = found node
// recurse into subdirs

// map-handles --data path/to/data/directory --file path/to/imported/structure/file

/** 
 * @todo describe me
 */
function map_handles($xpath, $element, $dir) {
  
  if (file_exists($dir.DIRECTORY_SEPARATOR.STRUCTURE_FILE)) {
    
    if (! is_readable($dir.DIRECTORY_SEPARATOR.STRUCTURE_FILE)) {
      echo "Can't read ", $dir.DIRECTORY_SEPARATOR.STRUCTURE_FILE, PHP_EOL;
      exit(E_ERROR);
    }
    
    $structure_dom = new DOMDocument();
    $structure_dom->load($dir.DIRECTORY_SEPARATOR.STRUCTURE_FILE);
    
    // A structure.xml file defines a single community or collection. 
    // Die if multiple child nodes found under root element.
    // $element->childNodes->length counts text nodes so loop & filter:
    $child_nodes = array();
    
    foreach ($structure_dom->documentElement->childNodes as $child) {
      if ($child->nodeType == XML_TEXT_NODE) {
        continue;
      }
      $child_nodes[] = $child;
    }

    if (sizeof($child_nodes) > 1) {
      echo 'Multiple community/collection definitions found in ';
      echo $dir.DIRECTORY_SEPARATOR.STRUCTURE_FILE, PHP_EOL;
      exit(E_ERROR);
    }
    
    // Fetch the name of the community/collection 
    $name_list = $child_nodes[0]->getElementsByTagName('name');
    
    // Multiple names? Die horribly.
    if ($name_list->length > 1) {
      echo 'Multiple names defined for community/collection in ';
      echo $dir.DIRECTORY_SEPARATOR.STRUCTURE_FILE, PHP_EOL;
      exit(E_ERROR);
    }
    
    // We have the name of the community/collection defined in 
    // the current directory's structure file
    $name = $name_list->item(0)->textContent;
    
    // The community/collection with a child <name> node = $name in
    // the IMPORTED structure will be a child of current $element node.
    $name_list = $xpath->query('child::*/child::name[text()="'. $name .'"]', $element);
    
    // There *should* only be a single node in $name_list read from IMPORTED structure,
    // where <name> = $name and is a grandchild of $element
    if ($name_list->length > 1) {
      echo 'Multiple names defined for community/collection ';
      echo $dir.DIRECTORY_SEPARATOR.STRUCTURE_FILE, PHP_EOL;
      exit(E_ERROR);
    }
    
    // Fetch & write handle ID to a text file
    $handle_id = $name_list->item(0)->parentNode->getAttribute('identifier');
    
    if (file_put_contents($dir.DIRECTORY_SEPARATOR.HANDLE_FILE, $handle_id.PHP_EOL) === FALSE) {
      echo 'Failed to write handle identifier to ', $dir.DIRECTORY_SEPARATOR.HANDLE_FILE, PHP_EOL;
      exit(E_ERROR);
    }
    
    // Move $elmeent down the IMPORTED structure: the parent of
    // our matching $name is the new parent.
    $element = $name_list->item(0)->parentNode;
  }

  // jump off again
  foreach (glob($dir.DIRECTORY_SEPARATOR.'*', GLOB_ONLYDIR) as $subdir) {
    map_handles($xpath, $element, $subdir);
  }
}

/** 
 * Return script usage description
 */
function usage() { 

$usage = <<<USAGE
 
  usage: map-handles [--help] --data [path/to/data] --file [path/to/imported/structure/file]

  --help           this message
  --data           path to sample data
  --file           path to imported structure file

  E.g., 
  
  map-handles --data /opt/dspace/data --file /opt/dspace/data/imported-structure.xml


USAGE;

  return $usage;
}
?>
