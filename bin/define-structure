#!/usr/bin/php
<?php
/**
 * Builds community / collection structure document for use by
 * structure-builder script.  This needs to be re-written as a Java
 * class similiar to other administrative tools.
 */
  
/* 
 * Named constants
 */

// Argument names identified with a prefix
define('ARG_PREFIX', '--');

// Argument names
define('ARG_HELP',    'help');
define('ARG_DATA',    'data');
define('ARG_OUTPUT',  'output');

// Root element of import structure doc
define('ELEMENT_ROOT', 'import_structure');

// Each data directory has a structure file that defines
// the community/collection to which it corresponds
define('STRUCTURE_FILE', 'structure.xml');


/* 
 *  Parse & validate arguments
 */
$args = parse_arguments($argv);

if (array_key_exists(ARG_HELP, $args)) {
  echo usage();
  exit();
}

foreach (array(ARG_DATA, ARG_OUTPUT) as $required_arg) {
  if (! array_key_exists(ARG_PREFIX.$required_arg, $args) or ! isset($args[ARG_PREFIX.$required_arg])) {
    echo PHP_EOL, 'Required argument missing: ', ARG_PREFIX.$required_arg, PHP_EOL;
    echo usage();
    exit(E_USER_ERROR);
  }
}

/*
 * Create a DOM to represent import structure. 
 * Begin construction at base of supplied data directory.
 */
if (! isset($element)) {
  $element = new DOMElement(ELEMENT_ROOT);
}

$structure_dom = new DOMDocument();
$structure_dom->appendChild(new DOMElement(ELEMENT_ROOT));

build_structure($args[ARG_PREFIX.ARG_DATA], $structure_dom, $structure_dom->documentElement);


/*
 * Write structure to output file
 */
if (file_put_contents($args[ARG_PREFIX.ARG_OUTPUT], $structure_dom->saveXML()) === FALSE) {
  echo PHP_EOL, 'Failed to write structure to ', $args[ARG_PREFIX.ARG_OUTPUT], PHP_EOL;
  exit(E_ERROR);
}

/**
 * Recursive function walks data directory structure, looking for 
 * structure.xml files. Child <community> or <collection> elements
 * (one community/collection definition per structure file) are 
 * appended to the DOM representing overall import structure.
 */
function build_structure($dir, $dom, $element) {
  
  if (file_exists($dir . DIRECTORY_SEPARATOR . STRUCTURE_FILE)) {
    $structure_doc = new DOMDocument();
    $structure_doc->load($dir . DIRECTORY_SEPARATOR . STRUCTURE_FILE);

    // A structure.xml file defines a single community or collection. 
    // Die if multiple child nodes found under root element.
    // $element->childNodes->length counts text nodes so loop & filter:
    $child_nodes = array();
    
    foreach ($structure_doc->documentElement->childNodes as $child) {
      if ($child->nodeType == XML_TEXT_NODE) {
        continue;
      }
      $child_nodes[] = $child;
    }

    if (sizeof($child_nodes) > 1) {
      echo 'Multiple community/collection definitions found in ';
      echo $dir, DIRECTORY_SEPARATOR, STRUCTURE_FILE, PHP_EOL;
      exit(E_ERROR);
    }
    
    // Append the single child to the structure doc we're building,
    // deep copy = TRUE
    $imported_child = $dom->importNode($child_nodes[0], TRUE);
    $element->appendChild($imported_child);
    
    // Move down the DOM before recursing into subdirectories
    $element = $imported_child;
  }
  
  foreach (glob($dir .DIRECTORY_SEPARATOR. '*', GLOB_ONLYDIR) as $subdir) {
    build_structure($subdir, $dom, $element);
  }
  
  return;
}

/** 
 * Parse command-line arguments of the '--argname value' or 
 * '--arg_no_value' variety
 */
function parse_arguments($args) {
  array_shift($args);

  $arg_index = 0;
  $parsed_args = array();
  
  while ($arg_index < sizeof($args)) {
    // We expect the next value in the list to be an argument name
    if (strpos($args[$arg_index], ARG_PREFIX) === FALSE) {
      echo usage();
      exit(E_USER_ERROR);
    }

    // Keep the current argument as a key
    $key = $args[$arg_index];
    
    // What if the key already exists?
    if (array_key_exists($key, $parsed_args)) {
      echo usage();
      exit(E_USER_ERROR);
    }
    
    // Nah, it's fine:
    $parsed_args[$key] = NULL;
    
    // Increment the index & exit if we're at the end of the line
    $arg_index++;
    if ($arg_index >= sizeof($args)) {
      break;
    }
    
    if (strpos($args[$arg_index], ARG_PREFIX) === FALSE) {
      // Assume it's a value for the current arg: store & increment
      $parsed_args[$key] = $args[$arg_index++];
    }
    // Otherwise, let the next iteration handle the next named arg.
  }
  return $parsed_args;
}

/** 
 * Return script usage description
 */
function usage() { 

$usage = <<<USAGE

  Walks sample data directory structure and builds an XML file that
  defines communities, sub-communties, and collections for import
  by the structure-builder admin script.
  
  usage: define-structure [--help] --data [path/to/data] --output [path/to/output/file]

  --help           this message
  --data           path to sample data
  --output         location of output file

  E.g., 
  
  define-structure --data /opt/dspace/data --output /opt/dspace/data/import-structure.xml


USAGE;

  return $usage;
}

?>